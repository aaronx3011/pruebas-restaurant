<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AR + Compass — North‑Locked 3D Model</title>
  <style>
    :root {
      --bg: #0f172a;        /* slate-900 */
      --panel: rgba(0,0,0,.55);
      --muted: #94a3b8;     /* slate-400 */
      --text: #e5e7eb;      /* gray-200 */
      --accent: #38bdf8;    /* sky-400 */
    }
    html, body { height: 100%; margin: 0; background: #000; color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    /* A‑Frame fills the screen; our UI floats on top */
    a-scene { position: fixed !important; inset: 0 !important; z-index: 1; }

    .overlay { position: fixed; inset: env(safe-area-inset-top) 0 auto 0; display: flex; justify-content: center; padding: 12px; z-index: 10; pointer-events: none; }
    .panel { pointer-events: auto; background: var(--panel); color: #fff; padding: 8px 12px; border-radius: 12px; font-size: 14px; display: inline-flex; gap: 8px; align-items: center; backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.22); }
    .panel button { appearance: none; border: 1px solid rgba(255,255,255,.25); border-radius: 10px; padding: 6px 10px; background: rgba(255,255,255,.08); color: #fff; cursor: pointer; }
    .panel a { color: var(--accent); }

    .hud { position: fixed; left: 0; right: 0; bottom: 0; padding: 10px 12px; display: grid; gap: 10px; background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.55) 25%); z-index: 10; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .card { background: rgba(0,0,0,.45); border: 1px solid rgba(255,255,255,.12); border-radius: 14px; padding: 10px; backdrop-filter: blur(6px); }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 6px 0; }
    .btn { appearance: none; border: 1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.08); color: #fff; padding: 10px 12px; border-radius: 10px; font: 600 14px/1.2 system-ui, sans-serif; cursor: pointer; }
    .btn:active { transform: translateY(1px); }
    label { font-size: 12px; color: #dbeafe; }
    input[type=range] { width: 100%; }
    .readout { font-weight: 700; }
    .muted { color: var(--muted); }
  </style>

  <!-- A‑Frame + AR.js -->
  <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.js"></script>
</head>
<body>
  <!-- Top status / camera controls -->
  <div class="overlay">
    <div class="panel">
      <span id="camStatus" class="muted">If you see black, tap Start (iOS needs a gesture).</span>
      <button id="btnStart">Start</button>
      <button id="btnFlip">Flip</button>
      <button id="btnSnap">📸</button>
    </div>
  </div>

  <!-- AR Scene -->
  <a-scene id="scene" embedded vr-mode-ui="enabled: false"
           renderer="alpha: true; antialias: true; precision: mediump; powerPreference: high-performance"
           arjs="sourceType: webcam; facingMode: environment; debugUIEnabled: false; videoTexture: true; trackingMethod: best; sourceWidth: 1280; sourceHeight: 720; displayWidth: 1280; displayHeight: 720;">
    <a-assets>
      <!-- Replace with your GLB/GLTF URL (GLB preferred) -->
      <a-asset-item id="model" src="BCool.glb"></a-asset-item>
    </a-assets>

    <!-- Lighting -->
    <a-entity light="type: ambient; intensity: 0.8"></a-entity>
    <a-entity light="type: directional; intensity: 0.8" position="1 2 1"></a-entity>

    <!-- Camera rig and anchor holder (we will place this toward geographic North) -->
    <a-entity id="rig">
      <a-entity id="camera" camera look-controls wasd-controls="enabled:false"></a-entity>
      <a-entity id="holder" position="0 0 -2">
        <a-entity id="modelEntity" gltf-model="#model" shadow="cast: true; receive: true"></a-entity>
      </a-entity>
    </a-entity>
  </a-scene>

  <!-- Bottom HUD: compass + model controls -->
  <div class="hud">
    <div class="grid">
      <div class="card">
        <div class="row"><label>Heading (° from North)</label><div class="readout" id="deg">—</div></div>
        <div class="row"><label>Status</label><div id="compStatus" class="muted">waiting…</div></div>
        <div class="row" style="grid-template-columns:auto 1fr auto; gap: 6px;">
          <button id="btnEnable" class="btn">Enable compass</button>
          <button id="btnCalNorth" class="btn" title="Point the phone’s TOP to real North, then tap">Calibrate (point to North)</button>
          <button id="btnTips" class="btn">Tips</button>
        </div>
        <div class="row"><label>North‑lock</label>
          <label class="readout"><input id="chkLock" type="checkbox" checked> Place model at true North</label>
        </div>
      </div>
      <div class="card">
        <div class="row"><label>Distance (m): <span id="distVal">2.0</span></label><input id="dist" type="range" min="0.5" max="6" step="0.1" value="2"></div>
        <div class="row"><label>Height (m): <span id="heightVal">0.00</span></label><input id="height" type="range" min="-1" max="2" step="0.05" value="0"></div>
        <div class="row"><label>Rotate Y (°): <span id="rotYVal">0</span></label><input id="rotY" type="range" min="-180" max="180" step="1" value="0"></div>
        <div class="row"><label>Scale: <span id="scaleVal">1.00</span></label><input id="scale" type="range" min="0.05" max="5" step="0.05" value="1"></div>
        <div class="row"><button id="btnReset" class="btn">Reset Pose</button><span class="muted">Snapshot saves PNG</span></div>
      </div>
    </div>
  </div>

  <script>
  // ====== Camera helpers ======
  const sceneEl = document.getElementById('scene');
  const camStatus = document.getElementById('camStatus');
  const btnStart  = document.getElementById('btnStart');
  const btnFlip   = document.getElementById('btnFlip');
  const btnSnap   = document.getElementById('btnSnap');

  function setCamStatus(msg){ camStatus.textContent = msg; }

  async function startAR(){
    try{
      const sys = sceneEl.systems && sceneEl.systems['arjs'];
      if (sys && sys.arSource && sys.arSource.ready === false) {
        await sys.arSource.start();
      }
      setCamStatus('Camera started');
    }catch(e){ setCamStatus('Start failed: ' + e.message); }
  }

  let usingFront = false;
  async function flipCamera(){
    const sys = sceneEl.systems && sceneEl.systems['arjs'];
    if (!sys || !sys.arSource) return;
    try {
      usingFront = !usingFront;
      await sys.arSource.stop();
      sys.arSource.parameters.facingMode = usingFront ? 'user' : 'environment';
      await sys.arSource.start();
      setCamStatus('Camera: ' + (usingFront ? 'front' : 'rear'));
    } catch (e) { setCamStatus('Flip failed: ' + e.message); }
  }

  document.addEventListener('visibilitychange', () => {
    const sys = sceneEl.systems && sceneEl.systems['arjs'];
    if (!sys || !sys.arSource) return;
    if (!document.hidden) {
      const video = sys.arSource.domElement;
      if (video && (video.paused || video.readyState < 2)) {
        sys.arSource.start().then(()=> setCamStatus('Resumed after tab switch'));
      }
    }
  });

  btnStart.addEventListener('click', startAR);
  btnFlip.addEventListener('click', flipCamera);

  // Snapshot
  btnSnap.addEventListener('click', ()=>{
    const renderer = sceneEl.renderer; if (!renderer) return alert('Renderer not ready.');
    renderer.preserveDrawingBuffer = true;
    const dataURL = renderer.domElement.toDataURL('image/png');
    const a = document.createElement('a'); a.href = dataURL; a.download = 'ar-photo.png'; a.click();
    renderer.preserveDrawingBuffer = false;
  });

  if (location.protocol !== 'https:' && !['localhost','127.0.0.1'].includes(location.hostname)) {
    setCamStatus('Use HTTPS or localhost for camera access');
  }

  // ====== Model controls ======
  const holder   = document.getElementById('holder');
  const modelEl  = document.getElementById('modelEntity');
  const dist     = document.getElementById('dist');
  const height   = document.getElementById('height');
  const rotY     = document.getElementById('rotY');
  const scale    = document.getElementById('scale');
  const distVal   = document.getElementById('distVal');
  const heightVal = document.getElementById('heightVal');
  const rotYVal   = document.getElementById('rotYVal');
  const scaleVal  = document.getElementById('scaleVal');
  const btnReset  = document.getElementById('btnReset');
  const chkLock   = document.getElementById('chkLock');

  function updatePoseReadouts(){
    distVal.textContent = parseFloat(dist.value).toFixed(1);
    heightVal.textContent = parseFloat(height.value).toFixed(2);
    rotYVal.textContent = parseFloat(rotY.value).toFixed(0);
    scaleVal.textContent = parseFloat(scale.value).toFixed(2);
  }

  function applyModelTransforms(){
    // Model’s own rotation/scale
    const y = THREE.MathUtils.degToRad(parseFloat(rotY.value));
    modelEl.object3D.rotation.set(0, y, 0);
    const s = parseFloat(scale.value); modelEl.object3D.scale.set(s, s, s);
  }

  [dist, height, rotY, scale].forEach(i => i.addEventListener('input', ()=>{
    updatePoseReadouts();
    applyModelTransforms();
    if (!chkLock.checked) {
      // If not locked to North, keep holder straight ahead at chosen distance
      holder.object3D.position.set(0, parseFloat(height.value), -parseFloat(dist.value));
    }
  }));

  btnReset.addEventListener('click', ()=>{
    dist.value = 2; height.value = 0; rotY.value = 0; scale.value = 1;
    updatePoseReadouts(); applyModelTransforms();
  });

  updatePoseReadouts(); applyModelTransforms();

  // ====== Compass (from your Page 1, adapted) ======
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  const degEl = document.getElementById('deg');
  const compStatus = document.getElementById('compStatus');
  const btnEnable = document.getElementById('btnEnable');
  const btnTips = document.getElementById('btnTips');
  const btnCalNorth = document.getElementById('btnCalNorth');

  function setCompStatus(ok, msg){ compStatus.innerHTML = `<span style="color:${ok?'#22c55e':'#f59e0b'}">${msg}</span>`; }

  function screenAngle(){
    if (screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
    if (typeof window.orientation === 'number') return (window.orientation + 360) % 360;
    return 0;
  }
  function normalize(d){ d = d % 360; return d < 0 ? d + 360 : d; }

  // EMA smoothing on the circle
  let ema = null; const SMOOTH = 0.15;
  function smoothHeading(value){
    if (value == null) return ema;
    if (ema == null) { ema = value; return value; }
    const delta = (((value - ema) + 540) % 360) - 180;
    ema = (ema + SMOOTH * delta + 360) % 360;
    return ema;
  }

  // Optional user offset (tap when pointing top edge to true North)
  let userOffset = 0;
  function applyUserOffset(h){ return normalize(h + userOffset); }

  // Adjust heading when phone is upright in portrait
  function postureAdjust(h, e){
    const beta = typeof e.beta === 'number' ? e.beta : 0;
    const ang = screenAngle();
    const upright = Math.abs(beta) >= 30;
    if (!upright) return h;
    if (ang === 0 || ang === 180) return normalize(h + 90);
    return h;
  }

  function computeHeadingFromEvent(e){
    if (typeof e.webkitCompassHeading === 'number') return normalize(e.webkitCompassHeading);
    if (typeof e.alpha === 'number'){
      let hdg = 360 - e.alpha;              // clockwise from North
      hdg = normalize(hdg + screenAngle()); // compensate device orientation
      hdg = postureAdjust(hdg, e);
      return hdg;
    }
    return null;
  }

  let listening = false;
  function startCompass(){
    if (listening) return;
    if ('ondeviceorientationabsolute' in window){
      window.addEventListener('deviceorientationabsolute', onOrientation, { passive: true });
      setCompStatus(true, 'using absolute orientation…');
    } else {
      window.addEventListener('deviceorientation', onOrientation, { passive: true });
      setCompStatus(true, 'listening for heading…');
    }
    listening = true;
  }

  async function requestIOSPermissionIfNeeded(){
    if (!isIOS) return true;
    const fn = window.DeviceOrientationEvent && DeviceOrientationEvent.requestPermission;
    if (typeof fn === 'function'){
      try { const state = await DeviceOrientationEvent.requestPermission(); if (state === 'granted') return true; setCompStatus(false, 'motion permission denied'); return false; }
      catch { setCompStatus(false, 'motion permission error'); return false; }
    }
    return true;
  }

  btnEnable.addEventListener('click', async ()=>{ const ok = await requestIOSPermissionIfNeeded(); if (ok) startCompass(); });
  btnTips.addEventListener('click', ()=> alert('Calibration tips:\n• Away from magnets/metal.\n• Slow “figure‑8”.\n• Allow motion permissions.\n• Keep posture consistent while testing.'));
  btnCalNorth.addEventListener('click', ()=>{ const v = Number(degEl.textContent); if (Number.isFinite(v)){ userOffset = normalize(0 - v); setCompStatus(true, `calibrated offset: ${userOffset.toFixed(0)}°`); } else { setCompStatus(false, 'no heading yet'); } });

  // ====== NORTH‑LOCK CORE: place holder toward geographic North ======
  function placeHolderTowardNorth(headingDeg){
    // Camera local axes: +X right, +Y up, -Z forward. We want to place the model at
    // azimuth = North in world space, which in camera space is rotated by -heading.
    const r = parseFloat(dist.value);
    const y = parseFloat(height.value);
    const H = headingDeg * Math.PI / 180; // radians
    const x = -r * Math.sin(H);  // left/right (negative = left when facing East)
    const z = -r * Math.cos(H);  // forward/back (negative = forward when facing North)
    holder.object3D.position.set(x, y, z);
  }

  function onOrientation(e){
    const raw = computeHeadingFromEvent(e);
    if (typeof raw === 'number' && !Number.isNaN(raw)){
      const h = applyUserOffset(raw);
      const s = smoothHeading(h);
      if (typeof s === 'number'){
        degEl.textContent = Math.round(s);
        if (chkLock.checked) {
          placeHolderTowardNorth(s);
        }
      }
    }
  }

  // Auto start on Android
  if (!isIOS) startCompass();
  (screen.orientation || window).addEventListener?.('change', () => { ema = null; });
  </script>
</body>
</html>

