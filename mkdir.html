<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>A‑Frame WebXR Hit‑Test • Plane Detection + Tap‑to‑Place</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; }
    .overlay { position: fixed; inset: env(safe-area-inset-top) 0 auto 0; display: flex; justify-content: center; padding: 12px; z-index: 10; pointer-events: none; }
    .panel { pointer-events: auto; background: rgba(0,0,0,.55); color: #fff; padding: 8px 12px; border-radius: 10px; font-family: system-ui, sans-serif; font-size: 14px; display: inline-flex; gap: 10px; align-items: center; backdrop-filter: blur(6px); }
    .panel button { appearance: none; border: 1px solid rgba(255,255,255,.25); border-radius: 8px; padding: 6px 10px; background: rgba(255,255,255,.08); color: #fff; cursor: pointer; }
    .hint { position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; background: rgba(0,0,0,.55); color: #fff; border: 1px solid rgba(255,255,255,.15); padding: 8px 12px; border-radius: 12px; z-index: 9; display:none; }
    #error { position: fixed; top: 12px; right: 12px; max-width: 380px; background: #2a1b1b; border:1px solid #844; padding:12px; border-radius:12px; display:none; white-space:pre-wrap; color:#fff; z-index: 20; font: 14px/1.3 system-ui, sans-serif; }
    a-scene { position: fixed !important; inset: 0 !important; z-index: 1; }
    /* Simple reticle */
    .reticle { width: 64px; height: 64px; border: 2px solid rgba(255,255,255,.9); border-radius: 50%; box-shadow: 0 0 0 2px rgba(255,255,255,.2) inset; }
  </style>

  <!-- A‑Frame core -->
  <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
</head>
<body>
  <div id="error"></div>

  <div class="overlay">
    <div class="panel">
      <span id="status">Move your phone slowly to detect a surface. Tap to place the object.</span>
      <button id="precam">Allow Camera</button>
      <button id="enter">Start AR</button>
    </div>
  </div>

  <div id="hint" class="hint">Surface found ✅ — tap to place</div>

  <a-scene id="scene" embedded vr-mode-ui="enabled: false"
           renderer="alpha: true; antialias: true; precision: mediump; powerPreference: high-performance"
           webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: .overlay"
  >
    <a-assets>
      <!-- Swap this for your own GLB/GLTF if desired -->
      <a-asset-item id="model" src="cube.glb"></a-asset-item>
    </a-assets>

    <!-- Lighting (AR often benefits from simple lights) -->
    <a-entity light="type: ambient; intensity: 0.9"></a-entity>
    <a-entity light="type: directional; intensity: 0.8" position="1 2 1"></a-entity>

    <!-- The reticle entity (hidden by default). We'll update its matrix from WebXR hit‑test. -->
    <a-entity id="reticle" visible="false" rotation="-90 0 0">
      <a-ring radius-inner="0.085" radius-outer="0.1" color="#ffffff" material="opacity: 0.9; transparent: true"></a-ring>
    </a-entity>

    <!-- Holder for the placed content -->
    <a-entity id="placed"></a-entity>
  </a-scene>

  <script>
    const statusEl = document.getElementById('status');
    const errorEl = document.getElementById('error');
    const hintEl = document.getElementById('hint');
    const precamBtn = document.getElementById('precam');
    const enterBtn = document.getElementById('enter');
    const sceneEl = document.getElementById('scene');

    function showError(msg){ console.error(msg); errorEl.textContent = (msg?.message||msg); errorEl.style.display = 'block'; }
    function setStatus(msg){ statusEl.textContent = msg; }

    // Pre‑flight camera permission (helps some browsers show a clearer prompt before WebXR)
    precamBtn.addEventListener('click', async () => {
      try{
        if (location.protocol !== 'https:' && !['localhost','127.0.0.1'].includes(location.hostname)) {
          showError('Use HTTPS or localhost for camera access.'); return;
        }
        const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        s.getTracks().forEach(t=>t.stop());
        setStatus('Camera permission granted ✅');
      }catch(e){ showError('Camera permission failed: ' + (e?.message||e)); }
    });

    // Custom component that performs WebXR hit‑test and tap‑to‑place
    AFRAME.registerComponent('xr-hit-test', {
      init(){
        this.hitTestSource = null;
        this.viewerSpace = null;
        this.refSpace = null;
        this.reticle = document.querySelector('#reticle');
        this.placed = document.querySelector('#placed');
        this.modelURL = document.querySelector('#model')?.getAttribute('src') || null;

        // On session start, set up hit‑test
        this.onSessionStart = async () => {
          const xr = this.el.renderer.xr;
          const session = xr.getSession();
          try{
            this.viewerSpace = await session.requestReferenceSpace('viewer');
            this.refSpace = await xr.getReferenceSpace();
            this.hitTestSource = await session.requestHitTestSource({ space: this.viewerSpace });
            hintEl.style.display = 'block';
            setStatus('Move phone to find a surface. Tap to place.');
          }catch(e){ showError('Hit-test init failed: ' + (e?.message||e)); }

          const onSelect = () => {
            if (!this.reticle.getAttribute('visible')) return;
            // Remove previous object if any
            while (this.placed.firstChild) this.placed.removeChild(this.placed.firstChild);
            // Place a model slightly above plane to look floating
            const holder = document.createElement('a-entity');
            if (this.modelURL) {
              const obj = document.createElement('a-entity');
              obj.setAttribute('gltf-model', '#model');
              obj.setAttribute('scale', '0.25 0.25 0.25');
              obj.setAttribute('shadow', 'cast: true; receive: true');
              holder.appendChild(obj);
            } else {
              // Fallback cube geometry
              const cube = document.createElement('a-box');
              cube.setAttribute('depth', '0.15');
              cube.setAttribute('height', '0.15');
              cube.setAttribute('width', '0.15');
              cube.setAttribute('color', '#39ff88');
              holder.appendChild(cube);
            }
            // Lift a little (8cm)
            const p = this.reticle.object3D.position.clone();
            holder.object3D.position.copy(p.add(new THREE.Vector3(0, 0.08, 0)));
            holder.object3D.quaternion.copy(this.reticle.object3D.quaternion);
            // gentle float animation
            holder.setAttribute('animation', 'property: position; dir: alternate; dur: 1200; easing: easeInOutSine; loop: true; to: 0 0.1 0');
            this.placed.appendChild(holder);
          };
          session.addEventListener('select', onSelect);

          // On end, clean up
          this.onSessionEnd = () => {
            hintEl.style.display = 'none';
            this.hitTestSource = null; this.viewerSpace = null; this.refSpace = null;
          };
          session.addEventListener('end', this.onSessionEnd);
        };

        this.el.renderer.xr.addEventListener('sessionstart', this.onSessionStart);
      },
      tick(){
        const xr = this.el.renderer?.xr;
        const session = xr && xr.getSession && xr.getSession();
        if (!session || !this.hitTestSource) return;
        const frame = xr.getFrame();
        if (!frame) return;
        const results = frame.getHitTestResults(this.hitTestSource);
        if (results.length) {
          const hit = results[0];
          const pose = hit.getPose(this.refSpace);
          this.reticle.object3D.matrix.fromArray(pose.transform.matrix);
          this.reticle.object3D.matrix.decompose(this.reticle.object3D.position, this.reticle.object3D.quaternion, this.reticle.object3D.scale);
          this.reticle.setAttribute('visible', true);
          hintEl.style.display = 'block';
        } else {
          this.reticle.setAttribute('visible', false);
          hintEl.style.display = 'none';
        }
      }
    });

    // Attach the component once the renderer is ready
    sceneEl.addEventListener('loaded', () => {
      // Basic environment checks
      if (!('xr' in navigator)) {
        showError('WebXR not available. Use Chrome on Android or Safari on iOS 17+.');
      }
      sceneEl.setAttribute('xr-hit-test', '');
    });

    // Manual start button helps on iOS (gesture requirement)
    enterBtn.addEventListener('click', async () => {
      try{
        if (location.protocol !== 'https:' && !['localhost','127.0.0.1'].includes(location.hostname)) {
          showError('Use HTTPS or localhost for camera access.'); return;
        }
        if (!('xr' in navigator)) { showError('WebXR not available on this browser/device.'); return; }
        const ok = await navigator.xr.isSessionSupported('immersive-ar');
        if (!ok) { showError('immersive-ar session not supported here.'); return; }
        // A‑Frame will start AR when user hits the built-in AR button, but we can force it:
        sceneEl.renderer.xr.setSession(await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        }));
        setStatus('AR session started.');
      }catch(e){ showError(e); }
    });

    // Status hint for HTTPS
    if (location.protocol !== 'https:' && !['localhost','127.0.0.1'].includes(location.hostname)) {
      setStatus('Use HTTPS or localhost for camera access.');
    }
  </script>
</body>
</html>
