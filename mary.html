<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ángulo hacia tu posición</title>
  <style>
    :root {
      --bg: #0f172a;
      --text: #e5e7eb;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(1200px 600px at 70% -10%, #0b1d34 0%, var(--bg) 45%);
      color: var(--text);
      display: grid;
      place-items: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial;
    }
    .angle {
      font-size: clamp(64px, 14vw, 160px);
      line-height: 1;
      letter-spacing: 0.5px;
      font-weight: 700;
      text-align: center;
      user-select: none;
    }
    .angle small {
      font-size: 0.35em;
      opacity: 0.8;
      margin-left: 0.1em;
    }
  </style>
</head>
<body>
  <div class="angle" id="angle">–<small>°</small></div>

  <script>
    // --- Utilidades (firmas intactas) ---
    const $ = (sel, root=document) => root.querySelector(sel);

    function fmtNum(n, digits=1) {
      if (Number.isFinite(n)) return n.toFixed(digits).replace(/\.0+$/,'');
      return '–';
    }
    function toRad(deg){ return deg * Math.PI / 180; }
    function toDeg(rad){ return rad * 180 / Math.PI; }
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371_000;
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const Δφ = toRad(lat2 - lat1);
      const Δλ = toRad(lon2 - lon1);
      const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    function initialBearing(lat1, lon1, lat2, lon2) {
      const φ1 = toRad(lat1), φ2 = toRad(lat2);
      const λ1 = toRad(lon1), λ2 = toRad(lon2);
      const y = Math.sin(λ2-λ1) * Math.cos(φ2);
      const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
      let θ = Math.atan2(y, x) * 180 / Math.PI;
      return (θ + 360) % 360;
    }
    function convertDistance(meters, unit) {
      switch(unit) {
        case 'km': return meters / 1000;
        case 'mi': return meters / 1609.344;
        case 'nm': return meters / 1852;
        case 'm': default: return meters;
      }
    }
    function bearingToCardinal(bearing) {
      const dirs = ['North','North-East','East','South-East','South','South-West','West','North-West'];
      return dirs[Math.round(bearing / 45) % 8];
    }

    // --- Config fija ---
    const A_LAT = 4.670373;
    const A_LNG = -74.055733;

    // --- Geolocalización en vivo ---
    let watchId = null;

    function onPosSuccess(pos) {
      const { latitude, longitude } = pos.coords;
      const brg = initialBearing(A_LAT, A_LNG, latitude, longitude);
      $('#angle').innerHTML = `${fmtNum(brg, 1)}<small>°</small>`;
    }

    function onPosError(err) {
      console.error(err);
      $('#angle').innerHTML = `–<small>°</small>`;
    }

    const geoOpts = { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 };

    (function start(){
      const isHttps = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
      if (!('geolocation' in navigator)) {
        console.warn('Geolocation not supported');
        return;
      }
      if (!isHttps) {
        console.warn('Use HTTPS or localhost for precise location');
      }
      watchId = navigator.geolocation.watchPosition(onPosSuccess, onPosError, geoOpts);
    })();
  </script>
</body>
</html>

